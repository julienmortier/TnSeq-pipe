---
title: "TnSeq -- mapping barcoded transposons to genome"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to map reads from a barcoded transposon library to the genome of a target organism. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)). The initial steps of processing next generation sequencing data was directly adapted from [Morgan Price's Feba repository](https://bitbucket.org/berkeleylab/feba/src/master/), see also `README.md` of this repository.

## Libraries

```{r, message = FALSE}
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(stringi)
```

## Annotation of mapped reads

As a prerequisite to assign genome-mapped reads to genes (or other coding regions of interest), we have to **prepare a gene table first**. This table serves as input for the script `DesignRandomPool.pl`, see `README.md` for this github repository. This table is nothing more than a slightly trimmed version of the (RefSeq) `*.gff` file that can be downloaded from NCBI genome.

All reference genome tables were already downloaded in `ref/`, and can be imported from there.

```{r, message = FALSE, warning = FALSE}
# get file names
filenames = list.files("../ref/", pattern = ".gff$")

# apply trimming function
df_ref <- lapply(filenames, FUN = function(filename) {
    
    # read tables
    read_tsv(paste0("../ref/", filename), skip = 9, col_names = FALSE) %>%
    
    # remove unnecessary rows and columns
    filter(X3 != "CDS", X3 != "region") %>%
    select(X1, X4, X5, X7, X3, X9) %>%
    
    # set column names
    rename_with(~ c("scaffold", "begin", "end", "strand", "desc", "locus_tag")) %>%
    
    # extract old and new locustag
    mutate(
      old_locus_tag = stri_extract_first(locus_tag, regex = "H16_[AB][0-9]*|PHG[0-9]*|HPF_[0-9]{5}"),
      new_locus_tag = stri_extract_first(locus_tag, regex = "(H16|HPF)_RS[0-9]{5}")
    ) %>%
    
    # remove old ID column
    select(-locus_tag)
  })

# inspect head of tables
for (l in df_ref) {print(head(l))}
```

----------

Export the modified tables to `ref/` folder.

```{r}
# assign new filenames
names(df_ref) <- gsub(".gff$", "_trimmed.tsv", filenames)

# and save to disk
silent <- lapply(names(df_ref), function(filename) {
  write_tsv(df_ref[[filename]], path = paste0("../ref/", filename))
})
```

After this, the actions outlined in `README.md` can be performed. This is mainly A) mapping reads to the genome and B) generating a read/barcode pool file (summary) from all mapped reads. These steps are performed using the original `perl` scripts from Morgan Price.

## Mapping statistics and distribution on genome

The next step is to inspect basic statistics of transposon insertions and their distribution over the genome.

### Basic statistics

First read in a pooled data table and display summary statistics. Remove barcodes without mapped position.

```{r, message = FALSE}
# set working directory
wd_path <- "../data/"

# set pool file name
pool_file <- paste0(wd_path, "pool/H16_barcode_pool.tsv")

# import
df_pool <- read_tsv(pool_file) %>%
  filter(!is.na(pos))
```

```{r, echo = FALSE, message = FALSE}
paste("Number of total reads:", sum(df_pool$nTot))
paste("Number of unique barcodes:", nrow(df_pool))
paste("Number of barcodes with >= 10 reads:", df_pool %>% filter(nTot >= 10) %>% nrow)
paste("Number of barcodes with only 1 read:", df_pool %>% filter(nTot == 1) %>% nrow)
paste("Number of barcodes with > 1 position:", df_pool %>% filter(n2 > 0) %>% nrow)
paste("Number of barcodes on -/+ strand:", df_pool %>% group_by(strand) %>%
  summarize(n = length(n)) %>% pull(n) %>% paste(collapse = ", "))
```

Next we can plot the frequency of reads per barcoded transposons.

```{r, message = FALSE}
plot_reads_per_bc <- histogram(~ log2(nTot) | paste("strand:", strand), df_pool,
  par.settings = custom.colorblind(), breaks = 8,
  between = list(x = 0.5, y = 0.5), xlim = c(-0.5, 7.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)

print(plot_reads_per_bc)
```


### Distribution over the genome

**Read frequency over genome**

Each transposon insertion is indexed with a position on the genome. We can now plot insertion frequency over the genome. There are different ways to do that depending on how the data is treated. The most simple case (as done below) plotting the number of reads per transposon versus its insertion site on the genome, broken down by chromosome type ('scaffold').

```{r}
plot_reads_on_genome <- xyplot(nTot ~ pos | scaffold,
  df_pool %>% arrange(pos),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  layout = c(1,3), type = "l", lwd = 1.5,
  scales = list(alternating = FALSE),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
  }
)

print(plot_reads_on_genome)
```

**Tn insertion frequency over genome**

However this does not really reflect the actual insertion *frequency*. For the frequency, what matters is the number of different, unique insertions per kb of the genome. We can apply a density function or generate a rolling mean to evaluate frequency. For the density function, we use a bandwidth of 1000 bp or 10,000 bp 'windows' that gives a good smoothing. However the Y axis ('density') should not be confused with the frequency (we can use a histogram instead).

```{r}
plot_Tns_on_genome <- densityplot( ~ pos | scaffold,
  df_pool %>% arrange(pos), bw = 10000,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  layout = c(1,3), type = "l", lwd = 1.5,
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.densityplot(x, plot.points = FALSE, ...)
  }
)

print(plot_Tns_on_genome)
```

### Mapping barcodes to genes

The first step before we proceed with gene mapping is to deal with barcodes that map to two different locations. Since bacteria like *R. eutropha* have multiple copies of the same operon with almost identical DNA sequence, we rather like to keep ambiguous Tn insertions instead of removing them (that would be the standard procedure for any other organism). To this end we remove all reads mapping to more than 2 positions and gather the alternative position in the same column as the primary

```{r}
df_pool <- df_pool %>% 
  
  # filter out reads that map to >= 2 alternative positions
  select(-nPastEnd) %>% filter(n2 < 2) %>%
  
  # combine values to one column for gather + spread
  unite("pos1", n, scaffold, strand, pos, sep = ";") %>%
  unite("pos2", n2, scaffold2, strand2, pos2, sep = ";") %>%
  
  # gather in one column
  gather(key, value, pos1:pos2) %>%
  
  # spread again
  separate(value, into = c("n", "scaffold", "strand", "pos"), sep = ";") %>%
  filter(scaffold != "NA") %>%
  mutate(n = as.numeric(n), pos = as.numeric(pos))
```

----------

The basic Feba scripts produce a table of barcodes, their frequencies and genomic position information. What we really want to know is how many transposons/barcodes are mapped to each gene, which position within a gene they have, how many barcodes do not map to a gene (intergenic, low importance), and how many genes were not hit by a transposon (probably essential). For this purpose we can use the function `foverlaps()` from package `data.table` to map transposon insertion sites to gene regions (or vice versa). The following part was inspired by previous work of Kyle Kimler ([github link](https://github.com/kylekimler/)).

```{r, message = FALSE}
library(data.table)

# prepare input data in form of data tables
dt_pool = data.table(df_pool)
dt_ref = data.table(df_ref$GCF_000009285.1_ASM928v2_genomic_trimmed.tsv)

#dummy begin/end columns are created in the pool file to allow foverlap function
dt_pool$begin <- dt_pool$pos
dt_pool$end <- dt_pool$pos

setkey(dt_ref, scaffold, begin, end)
df_pool_annotated <- foverlaps(dt_pool, dt_ref, by.x = c("scaffold", "begin", "end"), type = "within") %>%
  as_tibble %>%
  select(barcode, rcbarcode, nTot, key, scaffold, pos, begin, 
    end, strand, i.strand, desc, old_locus_tag, new_locus_tag) %>%
  rename(gene_strand = strand, tn_strand = i.strand)

head(df_pool_annotated)
```

### Gene insertion frequency

Now that all transposons are mapped to genes (if possible), we can calculate basic statistics about how much genes were hit, how many transposons inserted in a gene on average, and how many transposons hit intergenic regions. Since the number of transposon-mapped reads was low due to low quality sequencing run, this analysis is preliminary.

**Barcodes per gene type**

We filter ambiguous barcodes out (barcode mapping to more than one position). We can see that 25% of transposons inserted into intergenic regions, and the rest into genes/pseudogenes.

```{r, message = FALSE}
df_pool_annotated %>% 
  filter(key == "pos1") %>%
  group_by(desc) %>%
  summarize(n_barcodes = length(unique(barcode)))
```

----------

**Insertions per gene**

```{r, message = FALSE}
plot_insertions_per_gene <- df_pool_annotated %>% 
  filter(key == "pos1", !is.na(old_locus_tag)) %>%
  group_by(old_locus_tag) %>%
  summarize(n_barcodes = length(unique(barcode))) %>%
  
  histogram( ~ n_barcodes, .,
  par.settings = custom.colorblind(),
  breaks = 8,
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)

print(plot_insertions_per_gene)
```

----------

**Top 10 genes by number of Tn insertions**

```{r, message = FALSE}
df_pool_annotated %>% 
  filter(key == "pos1", !is.na(old_locus_tag)) %>%
  group_by(old_locus_tag) %>%
  summarize(n_barcodes = length(unique(barcode))) %>%
  arrange(desc(n_barcodes)) %>% slice(1:10)
```

----------

## Export result tables and figures

Export the annotated pool file containing the final barcodes and their locations in the genome.

```{r}
# create new file name
pool_file_annotated <- gsub(".tsv", "_annotated.tsv", pool_file)

# save to disk
write_tsv(df_pool_annotated, path = pool_file_annotated)
```

Export figures to `*.svg` image files.

```{r}
for (plots in c("plot_insertions_per_gene", "plot_reads_on_genome", 
  "plot_reads_per_bc", "plot_Tns_on_genome")) {
  
  svg(filename = paste0(wd_path, "../images/", plots, ".svg"), width = 6, height = 4)
  print(get(plots))
  dev.off()
}
```

