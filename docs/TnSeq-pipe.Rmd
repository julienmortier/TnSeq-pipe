---
title: "TnSeq -- mapping barcoded transposons to genome"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to map reads from a barcoded transposon library to the genome of a target organism. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)). The initial steps of processing next generation sequencing data was directly adapted from [Morgan Price's Feba repository](https://bitbucket.org/berkeleylab/feba/src/master/), see also `README.md` of this repository.

## Libraries

```{r, message = FALSE}
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(stringi)
```

## Mapping statistics and distribution on genome

The next step is to inspect basic statistics of transposon insertions and their distribution over the genome.

### Basic statistics

First read in a pooled data table and display summary statistics. Remove barcodes without mapped position.

```{r, message = FALSE}
# set working directory
wd_path <- "../data/"

# set pool file name
pool_file <- paste0(wd_path, "pool/H16_barcode_pool.tsv")

# import
df_pool <- read_tsv(pool_file) %>%
  filter(!is.na(pos))
```

```{r, echo = FALSE, message = FALSE}
paste("Number of total reads:", sum(df_pool$nTot))
paste("Number of unique barcodes:", nrow(df_pool))
paste("Number of barcodes with >= 10 reads:", df_pool %>% filter(nTot >= 10) %>% nrow)
paste("Number of barcodes with only 1 read:", df_pool %>% filter(nTot == 1) %>% nrow)
paste("Number of barcodes with > 1 position:", df_pool %>% filter(n2 > 0) %>% nrow)
paste("Number of barcodes on -/+ strand:", df_pool %>% group_by(strand) %>%
  summarize(n = length(n)) %>% pull(n) %>% paste(collapse = ", "))
```

Next we can plot the frequency of reads per barcoded transposons.

```{r, message = FALSE}
plot_reads_per_bc <- histogram(~ log2(nTot) | paste("strand:", strand), df_pool,
  par.settings = custom.colorblind(), breaks = 8,
  between = list(x = 0.5, y = 0.5), xlim = c(-0.5, 7.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)

print(plot_reads_per_bc)
```


### Distribution over the genome

**Read frequency over genome**

Each transposon insertion is indexed with a position on the genome. We can now plot insertion frequency over the genome. There are different ways to do that depending on how the data is treated. The most simple case (as done below) plotting the number of reads per transposon versus its insertion site on the genome, broken down by chromosome type ('scaffold').

```{r}
plot_reads_on_genome <- xyplot(nTot ~ pos | scaffold,
  df_pool %>% arrange(pos),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  layout = c(1,3), type = "l", lwd = 1.5,
  scales = list(alternating = FALSE),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
  }
)

print(plot_reads_on_genome)
```

**Tn insertion frequency over genome**

However this does not really reflect the actual insertion *frequency*. For the frequency, what matters is the number of different, unique insertions per kb of the genome. We can apply a density function or generate a rolling mean to evaluate frequency. Here, a defined window of 10,000 bp was used, and the sum of Tn insertion events per window was determined. Some of them might be duplicated barcodes because they map to more than one position. However these were still included here since they are often biologically relevant (CBB operon) and are low in number.

```{r, message = FALSE}
plot_Tns_on_genome <- df_pool %>% arrange(pos) %>%
  mutate(interval = cut_interval(pos, length = 10000, labels = FALSE)*10000) %>%
  group_by(scaffold, interval) %>%
  summarize(tn_frequency = length(pos)) %>%
  
  xyplot(tn_frequency ~ interval | scaffold, .,
    par.settings = custom.colorblind(),
    ylab = "Tn insertions / 10 kb",
    between = list(x = 0.5, y = 0.5),
    layout = c(1,3), type = "l", lwd = 1.5,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

print(plot_Tns_on_genome)
```

### Mapping barcodes to genes

The first step before we proceed with gene mapping is to deal with barcodes that map to two different locations. Since bacteria like *R. eutropha* have multiple copies of the same operon with almost identical DNA sequence, we rather like to keep ambiguous Tn insertions instead of removing them (that would be the standard procedure for any other organism). To this end, we remove all reads mapping to more than 2 positions and gather the alternative position in the same column as the primary mapping.

```{r}
df_pool <- df_pool %>% 
  
  # filter out reads that map to >= 2 alternative positions
  select(-nPastEnd) %>% filter(n2 < 2) %>%
  
  # combine values to one column for gather + spread
  unite("pos1", n, scaffold, strand, pos, sep = ";") %>%
  unite("pos2", n2, scaffold2, strand2, pos2, sep = ";") %>%
  
  # gather in one column
  gather(key, value, pos1:pos2) %>%
  
  # spread again
  separate(value, into = c("n", "scaffold", "strand", "pos"), sep = ";") %>%
  filter(scaffold != "NA") %>%
  mutate(n = as.numeric(n), pos = as.numeric(pos))
```

----------

The basic Feba scripts produce a table of barcodes, their frequencies and genomic position information. What we really want to know is how many transposons/barcodes are mapped to each gene, which position within a gene they have, how many barcodes do not map to a gene (intergenic), and how many genes were not hit by a transposon (probably essential). For this purpose we can use the function `foverlaps()` from package `data.table` to map transposon insertion sites to gene regions (or vice versa). The following part was inspired by previous work of Kyle Kimler ([github link](https://github.com/kylekimler/)).

```{r, message = FALSE}
library(data.table)

# prepare input data in form of data tables
dt_pool = data.table(df_pool)
dt_ref = data.table(df_ref$GCF_000009285.1_ASM928v2_genomic_trimmed.tsv)

#dummy begin/end columns are created in the pool file to allow foverlap function
dt_pool$begin <- dt_pool$pos
dt_pool$end <- dt_pool$pos

setkey(dt_ref, scaffold, begin, end)
df_pool_annotated <- foverlaps(dt_pool, dt_ref, by.x = c("scaffold", "begin", "end"), type = "within") %>%
  as_tibble %>%
  select(barcode, rcbarcode, nTot, key, scaffold, pos, begin, 
    end, strand, i.strand, desc, old_locus_tag, new_locus_tag) %>%
  rename(gene_strand = strand, tn_strand = i.strand)

head(df_pool_annotated)
```

### Gene insertion frequency

Now that all transposons are mapped to genes (if possible), we can calculate basic statistics about how many genes were hit, how many transposons inserted in a gene on average, and how many transposons hit intergenic regions.

**Barcodes per gene type**

We filter ambiguous barcodes out (barcode mapping to more than one position). We can see that 25% of transposons inserted into intergenic regions, and the rest into genes/pseudogenes.

```{r, message = FALSE}
df_pool_annotated %>% 
  filter(key == "pos1") %>%
  group_by(desc) %>%
  summarize(n_barcodes = length(unique(barcode)))
```

----------

**Insertions per gene**

```{r, message = FALSE}
plot_insertions_per_gene <- df_pool_annotated %>% 
  filter(key == "pos1", !is.na(old_locus_tag)) %>%
  group_by(old_locus_tag) %>%
  summarize(n_barcodes = length(unique(barcode))) %>%
  
  histogram( ~ n_barcodes, .,
  par.settings = custom.colorblind(),
  breaks = 8,
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)

print(plot_insertions_per_gene)
```

----------

**Top 10 genes by number of Tn insertions**

```{r, message = FALSE}
df_pool_annotated %>% 
  filter(key == "pos1", !is.na(old_locus_tag)) %>%
  group_by(old_locus_tag) %>%
  summarize(n_barcodes = length(unique(barcode))) %>%
  arrange(desc(n_barcodes)) %>% slice(1:10)
```


### Position of transposons within a gene

The mapping of a transposon to a gene also reveals its relative position within the gene. We can use this information to tag insertions as more likely to have a fitness effect, or not. We can also filter out transposons that lie outside the central portion of a gene (e.g. 10% margin to each side), or within a fixed flanking region (e.g. first or last 100 bp). The original FEBA protocol from Morgan Price uses a quality filter that requires transposons be located within the central 80% of a gene. We follow this definition and flag transposon outside the central portion of a gene as unreliable.

```{r}
# apply margin of 10% gene length
df_pool_annotated <- df_pool_annotated %>%
  mutate(
    gene_length = end-begin, central = between(pos,
    begin+0.1*gene_length, end-0.1*gene_length, NAbounds = NA)
  )
```

----------

How many transposons are central? We summarize. `NA` are transposons not mapped to a gene.

```{r, message = FALSE}
df_pool_annotated %>% group_by(central) %>% 
  summarize(frequence = length(pos))
```



## Export result tables and figures

Export the annotated pool file containing the final barcodes and their locations in the genome.

```{r}
# create new file name
pool_file_annotated <- gsub(".tsv", "_annotated.tsv", pool_file)

# save to disk
write_tsv(df_pool_annotated, path = pool_file_annotated)
```

Export figures to `*.svg` image files.

```{r}
for (plots in c("plot_insertions_per_gene", "plot_reads_on_genome", 
  "plot_reads_per_bc", "plot_Tns_on_genome")) {
  
  svg(filename = paste0(wd_path, "../images/", plots, ".svg"), width = 6, height = 4)
  print(get(plots))
  dev.off()
}
```

